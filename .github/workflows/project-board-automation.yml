name: Project Board Automation

permissions:
  contents: read
  issues: write
  pull-requests: write
  repository-projects: write

on:
  issues:
    types: [opened, edited, closed, reopened]
  pull_request:
    types: [opened, closed, edited]
  pull_request_review:
    types: [submitted]

env:
  # Set these in repo-level Variables or Secrets. For org-level Projects v2, provide ORG_LOGIN and PROJECTV2_NUMBER
  ORG_LOGIN: ${{ vars.ORG_LOGIN }}
  PROJECTV2_NUMBER: ${{ vars.PROJECTV2_NUMBER }}
  # For refactor progress tracking
  TRACKING_ISSUE_NUMBER: ${{ vars.TRACKING_ISSUE_NUMBER }}

jobs:
  manage-labels:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Label issues and PRs based on keywords
        uses: actions/github-script@v7
        with:
          script: |
            const { context, github } = require('@actions/github');
            const payload = context.payload;
            const repo = context.repo;
            
            let labels = [];
            let title = '';
            let body = '';
            
            if (payload.issue) {
              title = payload.issue.title;
              body = payload.issue.body || '';
            } else if (payload.pull_request) {
              title = payload.pull_request.title;
              body = payload.pull_request.body || '';
            }
            
            // Label refactor-related items
            if (title.toLowerCase().includes('refactor') || body.toLowerCase().includes('refactor')) {
              labels.push('refactor');
            }
            
            // Label bug-related items
            if (title.toLowerCase().includes('bug') || title.toLowerCase().includes('fix') || body.toLowerCase().includes('bug')) {
              labels.push('bug');
            }
            
            // Label feature-related items
            if (title.toLowerCase().includes('feature') || title.toLowerCase().includes('add') || body.toLowerCase().includes('feature')) {
              labels.push('enhancement');
            }
            
            // Label documentation
            if (title.toLowerCase().includes('doc') || body.toLowerCase().includes('documentation')) {
              labels.push('documentation');
            }
            
            if (labels.length > 0) {
              const number = payload.issue ? payload.issue.number : payload.pull_request.number;
              await github.rest.issues.addLabels({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: number,
                labels: labels
              });
            }

  manage-project-board:
    runs-on: ubuntu-latest
    needs: manage-labels
    steps:
      - uses: actions/checkout@v4
      - name: Manage project board cards
        uses: actions/github-script@v7
        with:
          # Use PAT if provided; otherwise fall back to GITHUB_TOKEN
          github-token: ${{ secrets.PROJECT_BOT_TOKEN || github.token }}
          script: |
            const { context, github } = require('@actions/github');
            const core = require('@actions/core');
            const payload = context.payload;
            const repo = context.repo;
            
            // -------- Projects v2 (GraphQL) --------
            // Inputs: ORG_LOGIN and PROJECTV2_NUMBER must be configured as repo Variables
            const ORG_LOGIN = process.env.ORG_LOGIN;
            const PROJECTV2_NUMBER = Number(process.env.PROJECTV2_NUMBER);
            const STATUS_FIELD_NAME = process.env.PROJECT_STATUS_FIELD || 'Status';
            if (!ORG_LOGIN || !PROJECTV2_NUMBER) {
              core.warning('ORG_LOGIN or PROJECTV2_NUMBER not configured. Skipping project item management.');
              return;
            }

            // Determine desired Status based on the event
            function computeStatus() {
              if (payload.issue) {
                if (payload.action === 'closed') return 'Done';
                if (payload.action === 'reopened') return 'In Progress';
                return 'To Do';
              } else if (payload.pull_request) {
                if (payload.action === 'closed') return 'Done';
                return 'In Progress';
              }
              return null;
            }

            const desiredStatus = computeStatus();
            if (!desiredStatus) {
              core.info('No relevant status change for this event.');
              return;
            }

            // Get the content node ID (Issue or PR)
            let contentId = null;
            if (payload.issue?.node_id) contentId = payload.issue.node_id;
            if (payload.pull_request?.node_id) contentId = payload.pull_request.node_id;
            // Fallback: fetch via REST if missing
            if (!contentId) {
              if (payload.issue) {
                const { data } = await github.rest.issues.get({ owner: repo.owner, repo: repo.repo, issue_number: payload.issue.number });
                contentId = data.node_id;
              } else if (payload.pull_request) {
                const { data } = await github.rest.pulls.get({ owner: repo.owner, repo: repo.repo, pull_number: payload.pull_request.number });
                contentId = data.node_id;
              }
            }
            if (!contentId) {
              core.warning('Could not resolve content node_id.');
              return;
            }

            // Load Project, fields, and Status options
            let project = null;
            try {
              const projectDataOrg = await github.graphql(
                `query($org: String!, $number: Int!) {
                  organization(login: $org) {
                    projectV2(number: $number) {
                      id
                      title
                      fields(first: 50) {
                        nodes {
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`,
                { org: ORG_LOGIN, number: PROJECTV2_NUMBER }
              );
              project = projectDataOrg.organization?.projectV2 || null;
            } catch (e) {
              core.info(`Org project lookup failed or not configured: ${e.message || e}`);
            }

            if (!project?.id) {
              core.info('Falling back to repository-level ProjectV2 lookup');
              const projectDataRepo = await github.graphql(
                `query($owner: String!, $name: String!, $number: Int!) {
                  repository(owner: $owner, name: $name) {
                    projectV2(number: $number) {
                      id
                      title
                      fields(first: 50) {
                        nodes {
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`,
                { owner: repo.owner, name: repo.repo, number: PROJECTV2_NUMBER }
              );
              project = projectDataRepo.repository?.projectV2 || null;
            }

            if (!project?.id) {
              core.setFailed('Failed to load ProjectV2 at org or repository level. Verify PROJECTV2_NUMBER and access.');
              return;
            }

            // Find the Status field (configurable name) and the desired option ID (with mapping to your project's option names)
            const fields = project.fields.nodes || [];
            const statusField = fields.find(f => (f.name || '').toLowerCase() === STATUS_FIELD_NAME.toLowerCase());
            if (!statusField) {
              core.setFailed(`Project doesn't have a '${STATUS_FIELD_NAME}' field.`);
              return;
            }
            const statusOptions = statusField.options || [];

            // Synonym mapping for your board
            const statusSynonyms = {
              'to do': ['to do', 'backlog', 'ready'],
              'in progress': ['in progress', 'in review'],
              'done': ['done']
            };
            const desiredList = statusSynonyms[desiredStatus.toLowerCase()] || [desiredStatus.toLowerCase()];
            const desiredOption = statusOptions.find(o => desiredList.includes(o.name.toLowerCase()));
            if (!desiredOption) {
              core.setFailed(`Status option '${desiredStatus}' not found in Project.`);
              return;
            }

            // Determine if the content is already in the project and get the itemId
            const itemInfo = await github.graphql(
              `query($contentId: ID!) {
                node(id: $contentId) {
                  __typename
                  ... on Issue {
                    projectsV2(first: 20) { nodes { id project { id } } }
                  }
                  ... on PullRequest {
                    projectsV2(first: 20) { nodes { id project { id } } }
                  }
                }
              }`,
              { contentId }
            );

            const nodes = itemInfo.node?.projectsV2?.nodes || [];
            let itemId = nodes.find(n => n.project?.id === project.id)?.id;

            // If not present, add to project
            if (!itemId) {
              const addRes = await github.graphql(
                `mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                    item { id }
                  }
                }`,
                { projectId: project.id, contentId }
              );
              itemId = addRes.addProjectV2ItemById?.item?.id;
            }

            if (!itemId) {
              core.setFailed('Failed to determine or create ProjectV2 item.');
              return;
            }

            // Update Status field value
            await github.graphql(
              `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(
                  input: {
                    projectId: $projectId,
                    itemId: $itemId,
                    fieldId: $fieldId,
                    value: { singleSelectOptionId: $optionId }
                  }
                ) {
                  projectV2Item { id }
                }
              }`,
              { projectId: project.id, itemId, fieldId: statusField.id, optionId: desiredOption.id }
            );
            core.info(`Updated ProjectV2 '${project.title}' item ${itemId} Status -> ${desiredStatus}`);

  track-refactor-progress:
    runs-on: ubuntu-latest
    needs: manage-project-board
    steps:
      - uses: actions/checkout@v4
      - name: Update refactor progress
        uses: actions/github-script@v7
        with:
          script: |
            const { context, github } = require('@actions/github');
            const core = require('@actions/core');
            const repo = context.repo;
            
            // Count open refactor PRs (use Search API to filter by label)
            const q = `repo:${repo.owner}/${repo.repo} is:pr is:open label:refactor`;
            const search = await github.rest.search.issuesAndPullRequests({ q, per_page: 1 });
            const totalRefactors = search.data.total_count || 0;
            
            // Update a progress issue or comment (assuming an issue #1 for tracking)
            const progressText = `## Refactor Progress\n\nTotal open refactor PRs: ${totalRefactors}\n\nLast updated: ${new Date().toISOString()}`;
            
            try {
              const issueNumber = Number(process.env.TRACKING_ISSUE_NUMBER) || 1;
              await github.rest.issues.createComment({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: issueNumber,  // configurable via repo Variables
                body: progressText
              });
            } catch (error) {
              // If issue doesn't exist, create it
              await github.rest.issues.create({
                owner: repo.owner,
                repo: repo.repo,
                title: 'Refactor Progress Tracking',
                body: progressText
              });
            }